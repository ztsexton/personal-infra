#cloud-config
package_update: true
package_upgrade: true
packages:
  - curl
  - ca-certificates
  - ufw
write_files:
  - path: /etc/systemd/system/traefik-port-forward.service
    permissions: '0644'
    owner: root:root
    content: |
      [Unit]
      Description=Port forwarding for Traefik NodePort
      After=network.target
      
      [Service]
      Type=oneshot
      ExecStart=/sbin/iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 30080
      ExecStart=/sbin/iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 30443
      RemainAfterExit=yes
      
      [Install]
      WantedBy=multi-user.target
  - path: /root/bootstrap.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/usr/bin/env bash
      set -euo pipefail
      echo "[bootstrap] Starting" | systemd-cat -t bootstrap -p info
      # Firewall
      ufw default deny incoming || true
      ufw default allow outgoing || true
      for p in 22 80 443; do ufw allow $p/tcp || true; done
      echo 'y' | ufw enable || true

      # Port forwarding for Traefik NodePort (80→30080, 443→30443)
      # This forwards standard HTTP/HTTPS ports to Traefik's NodePort service
      # - Port 80 (HTTP) → NodePort 30080 (Traefik web entrypoint)  
      # - Port 443 (HTTPS) → NodePort 30443 (Traefik websecure entrypoint)
      # This allows external visitors to access sites via standard ports without :30080/:30443
      echo "[bootstrap] Setting up port forwarding for Traefik" | systemd-cat -t bootstrap -p info
      systemctl enable traefik-port-forward.service
      systemctl start traefik-port-forward.service
      echo "[bootstrap] Port forwarding configured and enabled" | systemd-cat -t bootstrap -p info

      # Install k3s (idempotent guard)
      if ! command -v k3s >/dev/null 2>&1; then
        export K3S_TOKEN="${k3s_token}"
        DISABLE_ARG="${disable_arg}"
        INSTALL_K3S_EXEC="server $DISABLE_ARG --write-kubeconfig-mode=600"
        echo "[bootstrap] Installing k3s (DISABLE_TRAEFIK=${disable_traefik})" | systemd-cat -t bootstrap -p info
        curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="$INSTALL_K3S_EXEC" sh -
      else
        echo "[bootstrap] k3s already installed; skipping" | systemd-cat -t bootstrap -p info
      fi

      # Ensure kubectl symlink exists
      if ! command -v kubectl >/dev/null 2>&1 && [ -x /usr/local/bin/k3s ]; then
        ln -s /usr/local/bin/k3s /usr/local/bin/kubectl || true
      fi

      # kubeconfig convenience
      mkdir -p /root/.kube
      cp /etc/rancher/k3s/k3s.yaml /root/.kube/config
      chmod 600 /root/.kube/config
      PUBIP=$(curl -s ifconfig.me || curl -s https://api.ipify.org || echo 127.0.0.1)
      sed -i "s/127.0.0.1/$PUBIP/" /root/.kube/config || true

      MANIFEST_DIR=/var/lib/rancher/k3s/server/manifests
      mkdir -p "$MANIFEST_DIR"

      # Argo CD namespace
      cat > "$MANIFEST_DIR/00-argocd-namespace.yaml" <<'NS'
      apiVersion: v1
      kind: Namespace
      metadata:
        name: argocd
        labels:
          app.kubernetes.io/name: argocd
      NS

      # Argo CD installation via kubectl (more reliable than Helm)
      cat > "$MANIFEST_DIR/01-argocd-install.yaml" <<'ARGOCD'
      apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: argocd-installer
        namespace: kube-system
      ---
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: argocd-installer
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-admin
      subjects:
        - kind: ServiceAccount
          name: argocd-installer
          namespace: kube-system
      ---
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: argocd-install
        namespace: kube-system
      data:
        install.sh: |
          #!/bin/bash
          set -e
          echo "Installing Argo CD via kubectl..."
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          
          # Wait for Argo CD to be ready before patching
          echo "Waiting for Argo CD secret to be created..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          
          # Set admin password
          kubectl -n argocd patch secret argocd-secret \
            -p '{"stringData": {"admin.password": "${argocd_admin_password_bcrypt}", "admin.passwordMtime": "'$(date +%FT%T%Z)'"}}'
          
          # Configure insecure mode
          kubectl patch configmap argocd-cmd-params-cm -n argocd \
            -p '{"data":{"server.insecure":"true"}}'
          
          echo "Argo CD installation complete"
      ---
      apiVersion: batch/v1
      kind: Job
      metadata:
        name: argocd-install
        namespace: kube-system
      spec:
        template:
          spec:
            serviceAccountName: argocd-installer
            restartPolicy: OnFailure
            containers:
              - name: install
                image: rancher/kubectl:v1.29.3
                command: ["/bin/sh", "/scripts/install.sh"]
                volumeMounts:
                  - name: install-script
                    mountPath: /scripts
            volumes:
              - name: install-script
                configMap:
                  name: argocd-install
                  defaultMode: 0755
      ARGOCD

      # Always write root Application manifest (idempotent)
      cat > "$MANIFEST_DIR/10-argocd-root-application.yaml" <<'ROOTAPP'
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: root
        namespace: argocd
        annotations:
          argocd.argoproj.io/sync-wave: "-2"
      spec:
        project: default
        source:
          repoURL: ${git_repo_url}
          path: ${git_root_app_path}
          targetRevision: ${git_revision}
          directory:
            recurse: true
        destination:
          server: https://kubernetes.default.svc
          namespace: argocd
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
          syncOptions:
            - CreateNamespace=true
      ROOTAPP
      echo "[bootstrap] Root Application manifest written (k3s will apply when CRD ready)" | systemd-cat -t bootstrap -p info

      # Fallback Job: retry root Application until successful (safety net for timing issues)
      cat > "$MANIFEST_DIR/11-argocd-root-fallback.yaml" <<'FALLBACK'
      apiVersion: batch/v1
      kind: Job
      metadata:
        name: argocd-root-fallback
        namespace: argocd
      spec:
        backoffLimit: 10
        template:
          spec:
            serviceAccountName: default
            restartPolicy: OnFailure
            containers:
              - name: ensure-root
                image: alpine:3.19
                command:
                  - /bin/sh
                  - -c
                  - |
                    set -e
                    echo "[fallback] Waiting for Application CRD and root Application"
                    for attempt in $(seq 1 30); do
                      if kubectl get crd applications.argoproj.io >/dev/null 2>&1; then
                        if kubectl get app root -n argocd >/dev/null 2>&1; then
                          echo "[fallback] Root Application exists, success"
                          exit 0
                        else
                          echo "[fallback] CRD exists but root app missing, reapplying..."
                          cat <<'INNER_ROOT' | kubectl apply -f -
                    apiVersion: argoproj.io/v1alpha1
                    kind: Application
                    metadata:
                      name: root
                      namespace: argocd
                      annotations:
                        argocd.argoproj.io/sync-wave: "-2"
                    spec:
                      project: default
                      source:
                        repoURL: ${git_repo_url}
                        path: ${git_root_app_path}
                        targetRevision: ${git_revision}
                        directory:
                          recurse: true
                      destination:
                        server: https://kubernetes.default.svc
                        namespace: argocd
                      syncPolicy:
                        automated:
                          prune: true
                          selfHeal: true
                        syncOptions:
                          - CreateNamespace=true
                    INNER_ROOT
                          echo "[fallback] Root Application applied"
                          exit 0
                        fi
                      fi
                      echo "[fallback] Waiting for CRD (attempt $attempt/30)"
                      sleep 10
                    done
                    echo "[fallback] Timeout waiting for CRD or applying root Application"
                    exit 1
      FALLBACK
      echo "[bootstrap] Fallback Job created for root Application reliability" | systemd-cat -t bootstrap -p info

      echo "[bootstrap] Files seeded. Waiting for Argo CD server" | systemd-cat -t bootstrap -p info
      for i in {1..40}; do
        if kubectl get pods -n argocd 2>/dev/null | grep -q 'argocd-server'; then
          echo "[bootstrap] Argo CD detected" | systemd-cat -t bootstrap -p info
          break
        fi
        sleep 15
      done
      echo "[bootstrap] Complete" | systemd-cat -t bootstrap -p info
runcmd:
  - /root/bootstrap.sh
